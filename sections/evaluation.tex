\documentclass[class=article, crop=false]{standalone}

\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage[super]{nth}

\usepackage[margin=1in]{geometry}

\ifstandalone
\input{../src/listing.tex}
\fi

\ifstandalone
\input{../src/macros.tex}
\fi

\begin{document}

This chapter of my dissertation is concerned with comparing my CEK interpreter
implementation of Eff and my SHADE virtual machine with other existing solutions
implementing algebraic effect handlers. Specifically, the comparison is split
into two parts: to evaluate the performance of the CEK interpreter I compare
against the Eff interpreter and against the interpreter of Multicore OCaml.
The SHADE virtual machine is compared to Multicore OCaml's byte code interpreter.

At the end of this chapter a proof of concept web server is described. This is
more of a qualitative evaluation and is supposed to show what is possible to do
with effect handlers in the real-world.

\paragraph{Evaluation strategy and technical details.}

I will run multiple benchmarks each of which uses effect handlers in a different
way. Each benchmark is run 10 times and on the plots the arithmetic average of
the execution times is reported and the standard deviation as error bars. Data is
collected using GNU's \verb|time| command. During the measurements my laptop was
connected to the power supply and I tried to minimise noise in the measurements
by not running any other process (apart from a terminal) and turning off
unnecessary functionalities like WiFi, Ethernet, Bluetooth, etc.

All benchmarks are executed on a Lenovo Thinkpad X1 \nth{6} gen. with an Intel
Core i7-8565U CPU, 16GB of RAM using a single thread. The operating system in
use is a 64bit Ubuntu 18.04.4 LTS, Linux kernel version \verb|5.3.0-46-generic|.

Eff is compiled from its official GitHub repository at the time where the top
commit has SHA1 \verb|796900d|.
\footnote{The official repository is
\url{https://github.com/matijapretnar/eff/} at the time of writing.}
The version of Multicore OCaml used in the benchmarks is obtained by OPAM, the
identifier of the OPAM switch is \verb|4.06.1+multicore|.

\section{Exceptions}

The exception benchmark raises and catches exception-like effects (the
continuation is never resumed). I must add that in the OCaml benchmark I used
effects simulating exceptions rather than \emph{actual} OCaml exceptions. Actual
OCaml exceptions are implemented very efficiently in OCaml (they are not
resumable at all).

\begin{figure}
    \centering
    \includegraphics[width=40em]{eval_plots/interp_exception.png}
    \caption{The CEK interpreter performs better than Eff but worse than
    Multicore OCaml}
    \label{fig:exception-interpreters}
\end{figure}

Athough the OCaml interpreter beats the CEK interpreter in this benchmark, the
performance of the SHADE VM is comparable to MultiCaml's VM even though the
execution time for SHADE includes the compilation time to SHADEcode,
but the times for MultiCaml do not include compilation. I did not implement
serialization for my byte code and the compilation time is less and less
significant as we increase the number of exceptions.

\begin{figure}
    \centering
    \includegraphics[width=35em]{eval_plots/comp_exception.png}
    \caption{The peformance of SHADE is comparable to Multicore OCaml's}
    \label{fig:exception-bytecode}
\end{figure}

Note that as the byte code solutions are vastly more efficient than their
interpreter counterparts they are compared with a larger number of exceptions.
It takes around 63 seconds for the Eff interpreter to evaluate the benchmark
with 5000 exceptions, whereas this takes only 3.5 seconds for the CEK
interpreter. For SHADE VM the same takes around 200 milliseconds
(with compilation included), which is a 300-fold improvement!

\section{State and I/O}

The state benchmark implements an integer state and increments it every time the
\verb|Incr| effect is performed. The handler of the \verb|Incr| effect resumes
the continuation exactly once. The reason why I chose such a simple
computationally cheap operation as integer addition was that I wanted to measure
the performance of performing effects and resuming continuations. As $N$
increases we can be confident that the cost of performing effects and resuming
continuations will dominate the execution time.

\begin{figure}
    \centering
    \includegraphics[width=35em]{eval_plots/interp_state.png}
    \caption{Again, the CEK interpreter performs better than Eff but worse than
    the interpreter of Multicore OCaml}
    \label{fig:state-interpreters}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=35em]{eval_plots/comp_state.png}
    \caption{SHADE VM's performance is still head-to-head with Multicore OCaml}
    \label{fig:state-bytecode}
\end{figure}

\section{Non-determinism -- Solving the N-queens problem}

The $N$-queens
\footnote{The N-queens problem is concerned with finding the positions of $N$
queens on an $N \times N$ chessboard such that no two queens attack each other.}
benchmark is a backtracking program which resumes continuations more than once.
Here I don't compare against the CEK interpreter for the bigger benchmarks
because due to its naÃ¯ve implementation it slows down significantly after
$N > 14$. However, the performance of SHADE VM remains acceptable, although
worse than the VM of Multicore OCaml.

\begin{figure}
    \centering
    \includegraphics[width=35em]{eval_plots/comp_queens.png}
    \caption{SHADE VM loses against Multicore OCaml here but is still more
    performant than the Eff interpreter}
    \label{fig:n-queens}
\end{figure}

The reason why Multicore OCaml performs so much better than SHADE VM is what I
already mentioned in the Implementation chapter. Multicore OCaml implements
one-shot continuations and relies on the user to specify when a continuation
should be cloned.

\mylisting{caml}
{Cloning continuations must be done explicitly in Multicore OCaml}
{lst:multicaml-cloning}
{../code_examples/multicaml_cloning.ml}

\section{Concurrency -- Hello Online World!}

Cooperative multitasking can be implemented with algebraic effects and their
handlers too. We can realise \emph{green threads} as $\unitType \to \unitType$
functions which can be \lstinline|Spawn|ed and which are capable
of \lstinline|Yield|ing control. The reader might correctly suspect that
these operations will correspond to algebraic effects with the following types:
\begin{verbatim}
effect Yield : unit -->> unit;;
effect Spawn : (unit -> unit) -->> unit;;
\end{verbatim}
I built in two additional asynchronous effects in the runtime system of SHADE VM.
These are:
\begin{verbatim}
effect HTTPHello : int -->> unit;;
effect Accept : unit -->> int;;
\end{verbatim}
Both effects use non-blocking Unix system calls under the hood.
\verb|Accept| can accept an incoming network connection on port 8080 and returns
the new port number that can be used for further communication with a client.
The \verb|HTTPHello| effect takes a port number and sends a ``Hello World!''
HTTP message using an already established connection.

Now we can implement two types of green threads: the function
\lstinline|start_server| implements the main thread of the web server: it
accepts connections on the port 8080. If there is a new connection then a new
green thread is spawned for that connection, otherwise control is given to other
threads.

The \lstinline{say_hello} function takes a port number and
\emph{returns a green thread}: a $\unitType \to \unitType$ function that will
send the ``Hello World'' message on the port given but only if the underlying
socket is ready. If this is not the case it yields control and will retry later.

\begin{figure}
\begin{minipage}{0.6\textwidth}
\begin{verbatim}
let start_server () =
  let rec run () =
    let port = perform Accept () in
    match port with
    (* Yield if no incoming connection *)
    | -1 -> perform Yield ()

    (* Spawn thread for new connection *)
    | _ -> perform Spawn (say_hello port);
    run ()
  in
    run ()
;;
\end{verbatim}
\end{minipage}%
\begin{minipage}{.4\textwidth}
\begin{verbatim}
let say_hello port =
  let rec run () =
    let error = perform (HTTPHello port) in
    
    match error with
    | 0 -> () (* exit on success *)
    | -1 -> () (* exit if conn. closed *)

    (* try again if not ready *)
    | _ -> perform Yield (); run ()

  in run
;;
\end{verbatim}
\end{minipage}
\caption{Lightweight green threads}
\label{fig:green-threads}
\end{figure}

As effect handlers can simulate state it is possible to implement thread
scheduling with handlers too. The web server
thus can be started with something like:
\begin{verbatim}
with thread_scheduler handle
    start_server ()
\end{verbatim}
Based on the work of Dolan et al. \autoref{dolan2017concurrent} I claimed in
the Introduction that effect handlers give flexibility to programmers to
implement their own concurrency models which suits their application the most
while they reduce the complexity of runtime systems. This is a justification of
that claim (it is actually a simplified experiment from their paper). We see
that \verb|thread_scheduler| could implement any kind of scheduling policy by
handling the \verb|Yield| and \verb|Spawn| effects appropriately. The fact that
one can implement a toy webserver using one's own runtime system written from
scratch in less than a year justifies the second claim (the cited paper is a
result of the collaboration of 6 people).

\begin{figure}
    \centering
    \includegraphics[width=30em]{eval_plots/webserver.png}
    \caption{Although the performance of the webserver is not wonderful, it is
    my own runtime system that implements it and it can still handle ~100
    connections with a p90 time of 5 seconds with a throughput of 25 requests
    per second.}
    \label{fig:hello-online-world}
\end{figure}

\section{Summary}

\begin{itemize}
    \item The performance of the CEK machine and the SHADE VM was compared to
    other existing solutions
    \item It was found that my implementations beat the current Eff interpreter
    \item SHADE VM's performance is comparable to that of Multicore OCaml which
    is an industrial-strength compiler and runtime
    \item A webserver was written in Eff to highlight the benefits of using
    effect handlers in concurrent systems programming
\end{itemize}

\end{document}
