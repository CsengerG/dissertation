\documentclass[class=article, crop=false]{standalone}
\usepackage[subpreambles=true]{standalone}
\usepackage{import}
\usepackage{ebproof}
\usepackage[utf8]{inputenc}
\usepackage[table]{xcolor}
\usepackage{tikz}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{verbatim}
\usepackage{a4wide}
\usepackage[super]{nth}
\usepackage{float}
\usepackage{subcaption}
\usepackage{rotating}
\usepackage{pdflscape}
\usepackage{wrapfig}
\usepackage{booktabs}

\ifstandalone
\input{../src/efflang.tex}
\else
\input{./src/efflang.tex}
\fi

\ifstandalone
\input{../src/macros.tex}
\fi

\begin{document}

This chapter is concerned with the implementation of a CEK interpreter and
a SECD-like virtual machine for Eff. As the project is theory based, I will start this chapter
with continuing the Preparation and introducing a CEK machine for Eff, then my SECD-like
SHADE virtual machine, its byte code and compilation from Eff to this byte code.

It will be useful to think about the theory precisely and in-depth because it will
help to define the types and interfaces of the various OCaml modules of the project.
Indeed, I will often talk about the theory in the context of the abstract types
of the implementation of my project.

Following this I discuss my OCaml implementation and finally I write about the various 
software engineering practices I used to carry out the work.

\section{A CEK machine for Eff}

As mentioned in the Introduction, the Links programming language uses a CEK interpreter
to implement algebraic effects and their handlers \cite{hillerstrom2016compilation}.
My implementation uses a similar machine.

\subsection{Hlosures}

I talked a lot about closures in the Preparation chapter but the concepts discussed there
did not involve any handlers. In functional languages closures are used to make it possible
to handle functions as values because they can contain free variables. In Eff, handlers are
similar because they too can have free variables.

\begin{lstlisting}[language=efflang]
let make_handler n =
    let h = handler
    | val x -> x + n
    | effect (E x) k ->
        (* body of effect case using `n` *)
    | finally x ->
        (* body of finally case using `n` *)
;;
\end{lstlisting}

In the code snippet above there is a \verb|make_handler| function which returns a handler
\emph{parameterised} by \verb|n|. We see that we need to remember the value of \verb|n|
with each handler during runtime. We can simply attach an environment $E$ to a handler $H$ to
get around this problem just how we do this with closures when talking about functions.
In the rest of this chapter I will refer to such structures as \emph{hlosures} (handler closures)
and will denote the hlosure of handler $H$ in the context of environment $E$ as $\mathcal{H}(H, E)$.

\subsection{Hlosure frames}

When an effect is raised in an Eff program control is given to a matching effect case.
Now the current delimited continuation must be determined as it might be used in the body
of an effect case. The continuation is delimited by the with-handle block the matching
handler is handling. In the Preparation chapter we saw that we had access to the current
continuation at all times with the CEK machine, however we would struggle to decide which
closures belong to which with-handle block in the K stack.

During the runtime we always know about the current handler so we could simply tag all
closures in the K stack with the current handler at the time of its creation. However,
it is a much better idea to simply have a seperate K stack per handler, because
that will make the unwind operation on the K component of the stack machine much more efficient
(we will unwind handler and not the continuations one by one).

\noindent
\begin{minipage}{\textwidth}
\begin{center}
\begin{lstlisting}[language=caml]
type cek_id (** Identifiers *)
type cek_env (** Environments *)
type cek_control (** Control terms *)

(** Closures and kontinuations *)
type cek_kont = cek_id * cek_env * cek_control
type cek_k = cek_kont list

(** CEK machine configuration *)
type cek_machine = cek_control * cek_env * cek_k
\end{lstlisting}
\end{center}
\end{minipage}

Remember that handlers are represented as hlosures during runtime. Hence I will call the
structure described above a \emph{hlosure frame}. Hlosure frames are the new entries in
the K stack of my CEK machine. They consist of a hlosure and a kontinuation stack and
have the type \verb|cek_hlosure_frame = cek_hlosure * cek_kont list|.

\begin{lstlisting}[language=caml]
type cek_hlosure = cek_control * cek_env
type cek_hlosure_frame = cek_hlosure * cek_kont list
type cek_k = cek_hlosure_frame list

type cek_machine = cek_control * cek_env * cek_k
\end{lstlisting}

\subsection{CEK abstract machine}

Now that we know how we account for handlers and delimited continuations in the CEK
machine we can turn our attention to the transition rules of a CEK machine interpreting Eff.

\begin{myfigure}{A CEK machine interpreting Eff}{cek-machine}
    Initialisation:
    $$ c \longrightarrow \cek{c, \{\}, []} $$
    %
    Termination:
    $$ \cek{ \effVal e, \gamma, [] } \longrightarrow \text{halt with } \interp{e}\gamma$$
    Closures, hlosures and resumption from the continuation stack:
    $$ \cek{ \effVal h, \gamma, K} \longrightarrow \cek{\effVal \hlosure(h, \gamma), \gamma, K} $$
    $$ \cek{ \effVal (\effFun x \to c), \gamma, K} \longrightarrow \cek{\effVal (x.c, \gamma), \gamma, K } $$
    $$ \cek{ \effVal e, \gamma, ((x.c, \gamma') :: \mathcal{C}, \mathcal{H}) :: K } \longrightarrow
        \cek{c, \gamma'[x \mapsto \interp{e}\gamma], (\konts, \hlosure) :: K} $$
    %
    Function and continuation application:
    $$ \cek{ (\effFun x \to c)\ e, \gamma, K} \longrightarrow \cek{c, \gamma[x \mapsto \interp{e}\gamma], K } $$
    $$ \cek{ (\mathcal{R}(f, x.c, \gamma')\ v, \gamma, K} \longrightarrow \cek{c, \gamma'[x \mapsto v, f \mapsto \mathcal{R}(f, x.c, \gamma')], K } $$
    $$ \cek{\kappa\ e, \gamma, K } \longrightarrow \cek{ \interp{e} \gamma, \gamma, \kappa\ @\ K } $$
    %
    Perform and with-handle:
    $$ \cek{ \effPerform E(e,k), \gamma, K } \longrightarrow \cek{ \effPerform E(e,k), \gamma, K, [] }_{\text{unwind}} $$
    $$ \cek{ \textbf{with } \hlosure \textbf{ handle } c, \gamma, K } \longrightarrow \cek{ c, \gamma, ([], \hlosure) :: K } $$
    %
    Other standard rules:
    $$ \cek{ \textbf{let } x \leftarrow c_1 \textbf{ in } c_2, \gamma, (\konts, \hlosure) :: K} \longrightarrow 
    \cek{ c_1, \gamma, ((x. c_2, \gamma) :: \konts, \hlosure) :: K } $$
    $$ \cek{\effLet \effRec f\ x = c_1 \effIn c_2, \gamma, K} \longrightarrow
    \cek{c_2, \gamma[f \mapsto \mathcal{R}(f, x.c_1, \gamma)], K} $$
    \begin{align*}
    \cek{ \textbf{if } e \textbf{ then } c_1 \textbf{ else } c_2, \gamma, K } \longrightarrow \cek{ c, \gamma, K } \\
    \text{ where $c = c_1$ if $\interp{e} \gamma = \textbf{true}$; and $c = c_2$ otherwise}
    \end{align*}
\end{myfigure}

As expressions don't admit reduction we can simply interpret them in the context of an environment $\gamma$. For an expression $e$
this is written $\interp{e}\gamma$ and means that if $e$ is a variable then its value is looked up from $\gamma$. The runtime representation
of a functions $effFun x \to c$ is with closures and they are written as the tuple $(x.c, \gamma)$, similarly how it was done in the Preparation. 
Hlosures are written as $\mathcal{H}(h, \gamma)$ and the runtime representation of recursive functions $\effRec f\ x = c$ is with recursive
closures which also include the name of the function: $\mathcal{R}(f, x.c, \gamma)$.

Function application does not need a lot of explanation. When we apply a recursive closure $\mathcal{R}(f, x.c, \gamma)$ we make sure that we bind
$f$ to $\mathcal{R}(f, x.c, \gamma)$, so that $f$ can be invoked again in the function body. 

With the hlosure frame representation of K applying a continuation $\kappa$ is just the same as prepending it to $K$.
I would like to raise attention to how convenient this representation is. When an effect behaves like an exception (i.e., when $\kappa$ is not resumed)
all the handlers up to the handler handling the exception are all in $\kappa$ and are not in K anymore. However, when we do resume $\kappa$ then all
the handlers are put back in place again in K, thereby restoring the original execution context the effect was raised from.

This means that is no extra effort needed to manage the handler stack separately: the handler stack is managed automagically by the use of continuations.

The rule for the with-handle blocks simply prepends a new hlosure frame to K containing an empty continuation stack and the hlosure $\hlosure$.

\begin{myfigure}[.95]{Unwinding of the K component in the CEK machine}{fig:cek-k-unwind}
    \begin{align*}
        \cek{ \effPerform E(e,k), \gamma, (\konts, \hlosure) :: K, \kappa}_\text{unwind} \longrightarrow
        \cek{ \effPerform E(e,k), \gamma, K, \kappa@[(\konts, \hlosure)] }_\text{unwind} \\
        \text{ if $\hlosure = (H, \_)$ and handler $H$ does not handle effect $E$}
        \end{align*}
        \begin{align*}
        \cek{ \textbf{perform } E(e,k), \gamma, (\konts, \hlosure) :: K, \kappa}_\text{unwind} \longrightarrow
        \cek{ M, \gamma' [x \mapsto (\interp{e}\gamma), k \mapsto \kappa @ [(\konts, \hlosure)]], K} \\
        \text{ if $\hlosure = (H, \gamma')$ and handler $H$ handles effect $E$ with rule $\textbf{effect } E\ x \ k \to M$ }
        \end{align*}
\end{myfigure}

The way K is unwound upon performing an effect is described in \autoref{cek-k-unwind}. The CEK state is temporarily extended with a
fourth component which is an accumulator for $\kappa$ we are trying to determine. Here is the same in OCaml:

\begin{lstlisting}[language=caml]
(* int -> cek_value -> cek_k -> cek_k -> cek_state *)
let rec unwind eff_id eff_arg hlosure_frame_acc = function
| [] ->
    let msg = "Runtime exception: a handler handling effect with ID=" 
        ^ (string_of_int eff_id) ^ "could not be found" in
    raise (CEKerror msg)
| hf :: hfs ->
    let continuation = hlosure_frame_acc @ [hf] in
  
    (* Current hlosure frame matches effect *)
    if is_match eff_id hf then
        (* Obtain matching effect case *)
        let matching_effcase = List.find (fun effcase -> effcase.eff_id = eff_id) hf.hlosure.handler.effcases in
        
        (* Bind argument of effect and the current continuation to the corresponding indentifiers in the hlosure environment *)
        let env = hf.hlosure.env
        |> (Cek_env.add matching_effcase.arg_label eff_arg)
        |> (Cek_env.add matching_effcase.kont_label (CEKcont continuation)) in
        
        (* Return the new CEK state *)
        { c = matching_effcase.eff_control;
          e = env;
          k = hfs; }

    (* If no match is found the continue the unwinding hlosure frames *)
    else
        unwind eff_id eff_arg continuation hfs
;;
\end{lstlisting}

\section{The SHADE virtual machine}
\label{sec:shade-machine}

The SHADE virtual machine is a SECD-like virtual machine which was the goal of
my project.
The SHADE name is an anagram from the initials A,D,E,H,S -- the main
components of the machine.
It had many versions and the final version turned out to be surprisingly similar
to the solution Multicore OCaml uses with its fibres -- the heap-allocated fibres
of OCaml show a lot of resemblance with the shadows of the SHADE machine.

The SHADE virtual machine interprets SHADE byte code which will be described
in the next section. Here I give the description of the machine with its transition
rules.

The state of the machine at any point can be characterised with a two-tuple
$$ \langle A, D \rangle $$
where $A$ is the accumulator and $D$ is a list of \emph{shadows}, essentially a stack
of continuations like the dump in SECD machines.
A shadow is a four-tuple $$ \langle pc, E, H, S \rangle $$, where $pc$ is the
program-counter of the shadow, $E$ is an environment, $H$ is a hlosure and $S$ is
a stack.

The \emph{top-shadow} is a special shadow I will refer to often. To avoid having to refer to
it through the $D$ component I will use the notation $\langle A, d, D \rangle$ instead, to mean the SHADE state
 $\langle A, d :: D \rangle$.
In the program counter field ($pc$) of a shadow I will write the instruction the program counter
points to and its value interchangeably. On the left hand side of the transition rules it is more
convenient to refer to the instruction and on the right hand side it is often useful to write
$pc+1$ to mean that the program counter is incremented or write $L$ to mean
that we perform a jump to the label $L$.

\autoref{shade-machine} is only dealing with inter-shadow instructions. These are instructions which manipulate
the D component of the machine and implement the Eff-specific features (perform, resume, with-handle and
returning from with-handle blocks).

Intra-shadow instructions are standard stack machine instructions similar to those of the Caml Virtual Machine \cite{caml-vm}.
I won't give formal transition rules for these here. \autoref{tab:shade-bytecode} includes all SHADE instructions and explains their purpose in prose.

\begin{myfigure}[0.95]{SHADE machine transition rules}{fig:shade-machine}
    Initialisation:
    $$\text{program} \to \shade{\shUnit, (0, \{\}, H_{def}, []), []}$$
    Termination:
    $$ \shade{v, (\shHalt, E, H, S), D} \to v $$
    Transition rules for Eff-specific instructions:
    $$ \shade{\mathcal{C}(cp, \gamma), (\shCastShadow, E, H, \hlosure :: S), D} \to \shade{A, (cp, \gamma, \hlosure, []), (pc+1, E, H, \hlosure :: S) :: D} $$
    $$ \shade{A, (\shKillShadow, E, \hlosure(h, \gamma), S), D} \to  \shade{A, (L_{\text{valcase}(h)}, \gamma, \hlosure(h, \gamma),S), D} $$
    $$ \shade{A, (\shFin, E, H, \hlosure(h, \gamma) :: S), D} \to \shade{A, (L_{\text{fincase}(h)}, \gamma, (pc, E) :: S), D} $$
    $$ \shade{A, (\shThrow\ id, E, H, S), D} \to \shade{A, (\shThrow\ id, E, H, S), D, []}_\text{unwind}^{id} $$

    $$ \shade{A, (\shRett, E, H, S), D} \to \shade{A, D} $$
    $$ \shade{A, (\shApply, E, H, \mathcal{C}(cp, \gamma) :: S), D} \to \shade{A, (cp, \gamma, H, (pc, E) :: S), D} $$
    $$ \shade{A, (\shApply, E, H, \kappa :: S), D} \to \shade{A, \kappa\ @\ ((pc, E, H, S) :: D)} $$
\end{myfigure}

\begin{myfigure}[1]{Stack unwinding in SHADE}{fig:shade-stack-unwind}
    $$ \shade{A, \underbrace{(pc, E, H, S)}_d, D, \kappa }_\text{unwind}^{id} \text{ and } H \uparrow id \to \begin{cases}
        \text{Runtime exception} & \text{if } D = [] \\
    \shade{A, d, D', \kappa @ [d]}_\text{unwind}^{id} & \text{if } D = d' :: D' \end{cases} $$

    $$ \shade{A, (pc, E, \hlosure(h, \gamma), S), D, \kappa}_\text{unwind}^{id} \to
        \shade{A, (L_{\text{effcase}(h, id)}, \gamma[x \mapsto A, k \mapsto \kappa] ), D} \text{ if } h \downarrow id $$
\end{myfigure}


\subsection{SHADEcode -- an instruction set}

This section

\begin{table}
\centering
{\renewcommand{\arraystretch}{1.3}
\rowcolors{2}{gray!17}{white}
\begin{tabular}{p{3.2cm}p{6.5cm}p{4.2cm}}
    \toprule
    Instruction & Description & Action \\
    \midrule
    \vmPush & 
        Push the accumulator to the stack. &
        \verb|S := A :: S| \\
    \vmPop  &
        Remove the top element of the stack. &
        \verb|S := S.tail| \\
    \vmAcc{$n$} &
        Copy the $n^\text{th}$ element (0 indexed) of the stack in the accumulator. &
        \verb|A := S[n]| \\
    \vmConst{$c$} &
        Load the constant $c$ to the accumulator. &
        \verb|A := c| \\
    \vmHalt &
        Halt the SHADE machine with the value in A. &
        terminate with A \\
    \vmJump{$L$} &
        Jump to location L. &
        \verb|pc := adress of L| \\
    \vmBranchIfNot{$L$} & 
        If A = false then jump to location L. Otherwise continue with the next instruction. &
        \begin{tabular}[t]{@{}l@{}} \verb|pc := pc + 1| if \verb|A = true|\\\verb|pc := L| if \verb|A = false| \end{tabular} \\
    \vmApply &
        Apply the top of the stack to the accumulator. &
        see \autoref{fig:shade-machine} \\
    \vmRet &
        Return with the value in A. Restore the old program counter and environment from S. &
        see \autoref{fig:shade-machine} \\
    \vmRett & 
        Return from a value or effect case with the value in A. Destroy the top shadow and increment the program counter of the new top shadow. &
        see \autoref{fig:shade-machine} \\
    \vmMakeBox{$t$}{$n$} &
        Create a box with tag $t$ using $A$ and the top $n-1$ elements of S. & \\
    \vmGetField{$n$} &
        Load field $n$ (0 indexed) of a box to A. &
        \verb|A := A[n]|\\
    \vmListHead &
        Load the head of a list to A. &
        \verb|A := A.head| \\
    \vmListTail &
        Load the tail of a list to A. &
        \verb|A := A.tail| \\
    \vmMakeClosure{$L$}{$n$} &
        Form an environment of A and the top $n-1$ elements of S and create a closure with this environment of location L. &
        \begin{tabular}[t]{@{}l@{}}\verb|E = [A, S[0:N]];| \\ \verb|S.pop(N-1);| \\ \verb|A := closure(L, E)|\end{tabular} \\
    \begin{tabular}[t]{@{}l@{}}\textbf{makehlosure} $N$, $L_v$ \\ $L_f$, $L_{e_1}$, $L_{e_2}, ...$\end{tabular} &
        Similar to \vmMakeClosure{$L$}{$N$} but with many locations each corresponding to a handler case. &
        \begin{tabular}[t]{@{}l@{}}\verb|E = [A, S[0:N-1]];| \\ \verb|S.pop(N-1);| \\ \verb|A := hlosure(|$L_v$, $L_f$,\\ \quad\quad\quad\quad\quad $L_{e_1}$\verb|,.., E)|\end{tabular} \\
    binary operators \textbf{intadd}, \textbf{floatadd}, etc. &
        Perform a binary operation with A and S.top. &
        \begin{tabular}[t]{@{}l@{}}\verb|A := bop(A, S.top())|\\\verb|S.pop()|\end{tabular} \\
    \bottomrule
\end{tabular}}
\caption{SHADE instruction set}
\label{tab:shade-bytecode}
\end{table}

\subsection{Compiling from an IR to SHADEcode}

\begin{myfigure}[1]{Compilation from IR to SHADE bytecode}{fig:compilation}
    $$ \interp{\irId\ x}_s^\gamma = \text{where\_is}\ (x, s, \gamma) $$
    $$ \interp{\irConst\ c} = \textbf{const } c $$
    $$ \interp{\irBox\ (t, v_1 \dots v_n)}_s ^ \gamma = \interp{v_n}_s^\gamma; \vmPush; \interp{v_{n-1}}_{s+1}^\gamma; \vmPush; \dots \interp{v_1}_{s+n-1}^\gamma; \vmMakeBox{t}{n} $$
    $$ \underbrace{\interp{\irFun\ (x, body)}_s ^\gamma }_f = \text{fvs-to-stack} (s, \gamma, f); \vmMakeClosure{N}{L} $$
    $$ \underbrace{\interp{\irHandler\ (v, es, f)}_s^\gamma}_h = \text{fvs-to-stack} (s, \gamma, h); \vmMakeHlosure{N}{L_v}{L_f}{L_{e_1}, L_{e_2}, \dots} $$
    $$ \interp{\irVal\ v}_s ^ \gamma =  \interp{v}_s ^ \gamma $$
    $$ \interp{\irIf\ (v, e_1, e_2)}_s ^ \gamma = \vmBranchIfNot\ L_\text{false}; \interp{e_1}_s^\gamma; \vmJump\ L_\text{exit}; \vmLabel\ L_\text{false}; \interp{e_2}_s^\gamma; \vmLabel\ L_\text{exit} $$
    $$ \interp{\irLetIn\ (x, e_1, e_2)}_s^\gamma = \interp{e_1}_s^\gamma; \vmPush; \interp{e_2}_{s+1}^{\gamma[x \mapsto s]} $$
    $$ \interp{\irLetRecIn\ (f, x, body, e)}_s^\gamma = \text{fvs-to-stack}(f, x, body, s, \gamma); \vmMakeClosure{N}{L}; \vmPush; \interp{e}_{s+1}^{\gamma[f \mapsto s]} $$
    $$ \interp{\irPerform\ (id, v)} = \interp{v}_s ^ \gamma; \vmThrow\ id $$
    $$ \interp{\irWithHandle\ (h, e)}_s ^ \gamma = \interp{h}_s ^ \gamma; \vmPush; \text{fvs-to-stack}(e, s, \gamma); \vmMakeClosure{N}{L}; \shCast $$
    $$ \interp{\irBinOp\ (\mathtt{op}, v_1, v_2} = \interp{v_1}_s ^ \gamma; \vmPush; \interp{v_2}_{s+1}^\gamma; \text{instr-of}(\mathtt{op}) $$
    $$ \interp{\irFunApp\ (v_1, v_2)} = \interp{v_1}_s ^ \gamma; \vmPush; \interp{v_2}_{s+1} ^ \gamma; \vmApply $$
    $$ \interp{\irGetField\ (n, v)}_s ^ \gamma = \interp{v}_s ^ \gamma; \vmGetField{n} $$
    $$ \interp{\irListHead\ v}_s ^ \gamma = \interp{v}_s ^ \gamma; \vmListHead $$
    $$ \interp{\irListTail\ v}_s ^ \gamma = \interp{v}_s ^ \gamma ; \vmListTail $$
\end{myfigure}

\begin{figure}


    \caption{The compile-later relation}
    \label{compile-later}
\end{figure}

\section{How can SHADEcode implement Eff?}

I gave a formal but dry description of the SHADE machine and its bytecode in the previous section.
The reader might rightfully demand an explanation of why SHADE makes sense for Eff. In this section
I will show how the byte code can implement the various flow of control algebraic effect handlers allow.

It is clear that when no new shadow is cast (no with-handle is used) then the SHADE machine is essentially a Zinc machine with
all effects behaving like exceptions. The next page contains various examples and should give a good insight
into how everything fits together.

\begin{figure}
    \scalebox{.6}{
        \subimport{../figures/}{impl-no-perform.tex}
    }

    \caption{No effect is performed.}
    \label{fig:shadecode-no-effect}
\end{figure}

\begin{figure}
    \scalebox{.6}{
        \subimport{../figures/}{impl-exception.tex}
    }

    \caption{An effect is performed but its continuation is not resumed.}
    \label{fig:shadecode-exception}
\end{figure}


\begin{wrapfigure}{r}{0.5\textwidth}
    \begin{center}
    \scalebox{.6}{
        \subimport{../figures/}{impl-one-resume.tex}
    }
    \end{center}
    \caption{An effect is performed and its continuation is resumed.}
    \label{fig:shadecode-one-resume}
\end{wrapfigure}
 
\begin{landscape}
    \begin{figure}
        \centering
        \scalebox{.58}{%
            \subimport{../figures/}{impl-two-resume.tex} 
        }
        \caption{Multiple resumptions}
        \label{fig:shadecode-two-resume}
    \end{figure}
\end{landscape}


\section{OCaml implementation}

\subsection{Frontend -- Parsing and the IR}

<code example here where val is weird>

First De Bruijn indices on syntax tree.
Match is not supported but we have let (x,y) =
atomic patterns
continue k is rewritten to function application

Then delete the expression/computation distinction and convert into
an intermediate representation.

The intermediate representation is in A-normal form 

\subsection{CEK implementation}

In OCaml, the implementation closely follows the transition rules of the abstract machine.

We represent a CEK state with the type \verb|cek_state|:
\begin{verbatim}
    type cek_state = {
        c : cek_control;
        e : cek_environment;
        k : cek_hlosure_frame list;
    }
\end{verbatim}

The most interesting is the \verb|cek_hlosure_frame list|:
\begin{verbatim}
    type cek_hlosure_frame = {
        hlosure : cek_hlosure;
        kont_stack : cek_closure list;
    }
\end{verbatim}

\subsection{Compiling to SHADEcode}


\begin{itemize}
\item Concrete syntax differs slightly from abstract syntax
\item De Bruijn indices
\begin{itemize}
    \item Local environment
    \item Global environment
\end{itemize}
\item LetArgs --> Fun(Fun(...)) -- Something similar with sums and tuples and variants
\item LetRec --> RecFun ...
\item IR is ANF-like -- Makes the compilation ``easy''
\end{itemize}

\section{Compilation and back-ends}

example where handler has free variables

\begin{itemize}
    \item Hillerstrom Master dissertation.
    \item Closures, hlosures, delimited continuations, concatenation of continuations
\end{itemize}

\begin{itemize}
    \item Type in rules
\end{itemize}





\section{Software Engineering}

\subsection{Interfaces}
\subsection{Modules}
\begin{itemize}
    \item yoyo.ml
\end{itemize}

\subsection{Testing}
- regression testing
- tests

\subsection{Version control}
- via Git + Github
- Each new feature had its own branch + quick bugfix branch
- Refactor

\subsection{OPAM}
- The project is packaged as an OCaml package and is available under the name SHADE
- Can be installed with opam install shade

\subsection{Documentation}
- documentation is generated by odoc
- mli files and (** comments *)
- used this when I refactored code and to help structure my thoughts

\section{Summary}

2 sections

Theory -- derived
SHADE VM formally given -- allows others to come up with other implementations
An actual OCaml implementation was described
Software engineering practices were talked about

\end{document}