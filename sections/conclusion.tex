\documentclass[class=article, crop=false]{standalone}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}

\usepackage[margin=1in]{geometry}

\begin{document}

The project was a success. My success criterion was to implement a 
syntax-level interpreter for Eff, to design a low-level byte code for Eff,
to implement a compiler which can transform Eff programs into a linearised
representation and finally to implement a virtual machine which is capable of
interpreting that byte code. Furthermore, the above components had to be
reasonably efficient when compared to existing solutions.

The work described above was carried out and all components were successfully
implemented. The Evaluation chapter justifies the success of the project.
Both my CEK interpreter and my SHADE VM outperformed Eff on various
benchmarks and the performance of SHADE VM was often comparable to that of
Multicore OCaml.

\section{Travel Diary}

This dissertation is actually a story about a journey
which starts in the theoretical valleys of Mathematics, leads through the more
practical (but still quite theoretical) areas of Computer Science and finally
ends in the realms of practical Systems Programming.

% motivated by ...
% requires side effects, effects, Eff, designed, compiled, VM, returning 
In the Implementation chapter an implementation of a higher level CEK evaluator
(interpreting source terms) was described along with its abstract machine
semantics. Furthermore, the SECD-like SHADE VM is derived for Eff as well as
its instruction set (SHADEcode). A compiler is designed from Eff to SHADEcode.
The SHADE machine is my own ``invention'', although it turned out to be rather
similar to how Multicore OCaml implements algebraic effect handlers
\footnote{In particular, shadows and fibres seem to be almost the same.}.

The Evaluation chapter was concerned with comparing the CEK evaluator and the
SHADE VM to existing solutions, namely Multicore OCaml and the official
Eff interpreter. We found that the SHADE VM is reasonably efficient even without
implementing any optimisations. It was also shown how algebraic effects and
their handlers could be used for systems programming by exhibiting a toy web
server implementation in Eff.

\section{Further work}

The fact that there are algebraic theories behind algebraic effects and their
handlers allows us to prove certain compiler transformations correct by
equational reasoning. This gives us the opportunity to take a set of effect
equations (for instance, the equation $\mathtt{assign}(x,y); \mathtt{assign}(x,z) =
\mathtt{assign}(x, z)$ would show that the first \texttt{assign} can be optimised
away) and generate new optimisations (perhaps entirely new ones no-one has
thought about yet or ones that are dependent on the semantics of some effects).

Type and effect systems \cite{bauer2013effect} allow for even more optimisations
and the opportunity to parallelise independent parts of programs. As hardware is
getting increasingly parallel such optimisations can help us to get the most out
of our multicore machines.

My implementation was concerned with only the core features of Eff. There would
be countless ways to improve the compiler or the virtual machine. One of the
most interesting improvements would be to design a custom garbage collector for
Eff which might be another Part II project. The rules of SHADE VM are simple
enough that a byte code interpreter for SHADEcode should not be too hard to
implement in a low-level language such as C.

The project is packaged up as an OPAM package and I intend to make it available
on Github for other programming language enthusiasts.

% FURTHER WORK ON SYSTEMS PROGRAMMING

\section{Self-reflection}

If I were to start the project again I would try to be less ambitious. I vastly
underestimated the intellectual challenge behind continuations, handlers and
control operators.

At the beginning of the project I got a bit carried away with syntactic sugar
and trying to implement a lot of features of the language properly. This proved
to be counterproductive and I had to abandon these efforts. If I had to do this
again I would make the development even more iterative than it was: I would
design a smaller minimal viable product first, build a very minimal but working
(and tested!) pipeline and then iterate more on improvements. This was my
strategy when developing, but I could do it better the next time.

\paragraph{Closing thoughts}

Furthermore, I think there is a lack of elementary material concerning this
topic on the web. I am hoping that my Preparation chapter and this dissertation
as a whole will in some ways help popularise algebraic effects and their
handlers and that readers of this document will find them less cryptic than I
first did.

\end{document}
