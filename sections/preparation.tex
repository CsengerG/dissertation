\documentclass[class=article, crop=false]{standalone}
\usepackage[subpreambles=true]{standalone}
\usepackage{import}

\usepackage{tikz}
\usepackage{hyperref}

\begin{document}

This chapter of my dissertation describes the work that was undertaken
before any code was written, contains the starting point of my project
and the development methodology I used to carry out the work as well as
it contains a brief survey of the background knowledge I needed to
acquire to be able to start working on the project.

\section{The programming language Eff}

Eff is a programming language based on algebraic effect handlers.
Essentially, it is a pure subset of OCaml \cite{ocaml-website} extended with a few extra
keywords which implement effects and effect handlers: \verb|effect|,
\verb|perform|, \verb|handler|, \verb|continue|, \verb|with-handle| and \verb|finally|.
What follows is a brief introduction of these features by using the
unmissable Hello World example.

\subsection{Effects}

Effects lie in the heart of Eff (hence the name). A programmer can define
effects using the \verb|effect| keyword, the effect's name (effect names must
be capitalized just like OCaml variant tags) and its type. An effect definition
can be seen on \autoref{fig:effect-perform-keywords}. Effects always have a type of the
form $\alpha \to \beta$ for some types $\alpha$ and $\beta$.

\begin{figure}[hbt!]
  \begin{verbatim}
    effect Print : string -> unit;;
    ...
    let () = perform (Print "Hello World");;
  \end{verbatim}
  \caption{Printing can be thought of as an effect with an argument of type
  string and a result of type unit.}
  \label{fig:effect-perform-keywords}
\end{figure}

\subsection{Performing effects}

Effects behave a bit like functions as we could see from their types above.
Once an effect of type $\alpha \to \beta$ is defined we can invoke it
using the \verb|perform| keyword and with an argument of type $\alpha$.
The type of the result is $\beta$.\footnote{Too childish? How to say more concisely?}

The \verb|perform| keyword is similar to \verb|raise| in OCaml or to \verb|throw|
in Java in that when we perform an effect the control will go to an effect
handler (this would be an exception handler in OCaml or Java) or the program
will terminate with an exception if no handler can handle the effect.

\subsection{Handlers}

Handlers give meaning to effects: this is what programmers can use to specify
what they mean by \verb|Print|. Without a handler an effect can be declared, but when
performed, can only cause a program to terminate with an exception.

Handlers are first-class citizens (i.e., values) in Eff. One can define them with the
\verb|handler| keyword by specifying \emph{rules}.
An example can be seen on \autoref{fig:handler-keyword}.

\begin{figure}
  \begin{verbatim}
    let prepending_print_handler = handler
      | result -> (result, "")
      | effect (Print message) k ->
        let (cont_result, cont_output) = continue k () in
        (cont_result, message ^ cont_output)
      | finally x -> x
  \end{verbatim}
  \caption{A handler definition consisting of 2 rules (a value rule and an effect rule).
  The effect rule first resumes the rest of the program to obtain its result and its output.
  Printing out \texttt{message} is implemented as prepending
  it to the output of the rest of the program.}
  \label{fig:handler-keyword}
\end{figure}

To complete our Hello World example we must be able to use this handler. This is done
using a \emph{with-handle block} as illustrated on \autoref{fig:hello-world}.

\begin{figure}
  \begin{verbatim}
    with prepending_print_handler handle
      perform (Print "Hello ");
      perform (Print "World!")
  \end{verbatim}
  \caption{The Hello World example in Eff. The code above evaluates to the pair \texttt{("Hello World!", ())}.}
  \label{fig:hello-world}
\end{figure}

As handlers are values, they have their own type. This is discussed later in [TODO: ref to Type and Effect System section].

There are a few aspects of the code that can be strange on the first sight. The first
is the rules involved in the declaration.

\subsubsection{Handler rules}

One can use three types of rules in a handler: a \emph{value rule}, an \emph{effect rule} or
a \emph{finally rule}.

A value rule has the form $x \to c$.
It takes the result of a computation enclosed by a with-handle block, binds it to the
identifier $x$ and performs the computation $c$. This is a rule that describes how to handle the result of a computation.
In \autoref{fig:handler-keyword} we are simply saying that if the computation handled by this
handler has finished computing without invoking any effects, then we are returning a pair containing
the result of the computation and the empty string (this reflects that nothing was printed).

An effect rule is a generalisation of SML's \cite{milner1997definition} \verb|handle|. It differs from it in
that it also captures the \emph{continuation} (\verb|k| above) of the computation enclosed
by the with-handle block handling the effect. Such a continuation can be \emph{resumed} with
the \verb|continue| keyword. Note that when an effect of type $\alpha \to \beta$ is handled,
we get access to its argument of type $\alpha$ and we can resume its continuation if we provide
the continuation with a value of type $\beta$ it expects (this is why we resume the continuation
by giving it \verb|()| in \autoref{fig:handler-keyword}---\verb|Print| is of type $string \to unit$).

Finally rules are just syntactic sugar for let wrappers around with-handle blocks.
That is, $\textbf{finally } r \to f$ does the same as $\textbf{let } r \leftarrow \textbf{with } v \textbf{ handle } c \textbf{ in } f$.
Finally rules were introduced to avoid having to use such inconvenient let wrappers \cite{bauer2015programming}.

A handler can have any number of effect rules (even zero) but only at most one finally rule and at most one value rule.
Value rules and finally rules are optional. When they are avoided they are assumed to be identities (i.e.,
\verb|x -> x| or \verb|finally x -> x| respectively).

\section{Continuations and control operators}

Although continuations came up briefly in the previous section I didn't explain what they are in detail.
This section is devoted to this because continuations are playing a crucial role in Eff and in what follows
in this dissertation.

Continuations were first discovered in 1964 by van Wijngaarden \cite{reynolds1993discoveries}.

\subsection{Delimited continuations}

Delimited continuations 

% check this out
% https://en.wikipedia.org/wiki/Delimited_continuation

\subsection{Landin's J operator}

The mechanical evaluation of expressions \cite{landin1964mechanical}.

\section{Type and effect systems}

\section{Virtual machines}

\subsection{The CEK machine}

\subsection{The SECD machine}

\section{Choice of tools}

\section{Licensing}

It is important to mention that the project fulfills licensing criteria. The dependencies of this project are
listed below with their licenses:
\begin{itemize}
\item The OCaml toplevel, version 4.06.0, GNU Lesser General Public License (LGPL) version 2.1
\item \emph{menhir} parser generator, version 20190924, GNU Library General Public License version 2
\item \emph{Alcotest}, version 0.8.5, ISC license
\item OPAM (OCaml Package Manager), version 2.0.4, GNU Lesser General Public License (LGPL) version 2.1
\item \emph{Core} standard library by Jane Street, v0.11.3, MIT license
\end{itemize}
To the best of my knowledge these licenses allow the way I am using the software mentioned above.

\section{Starting point}

The starting point of my project didn't change since the writing of the project proposal [TODO: ref. appendix here]:
\begin{itemize}
  % knowledge backround
  \item I read briefly about Eff and algebraic effect handlers before starting my project. This was necessary
    because the Tripos does not cover this topic.
  \item I used SML and OCaml before to implement simple interpreters for toy programming languages.
  \item I also had a look at the OCaml ecosystem to check if it has stable build system, if testing frameworks are available
    and whether lexer and parser generators exist.
  \item I had basic familiarity with utility tools such as version control, various IDEs and Unix-like command line interfaces.
\end{itemize}

\section{Requirements analysis}

% a lot of knowledge needed to be acquired
% CEK interpreter has 2 goals: one to test my understanding and the other to give a baseline

\section{Development methodology}

\subsection{Structure of the project}

\subsection{Timeline}

\subsection{Correctness and testing}

Crucial to show correctness for project success. The timeline, the testing strategy and the structure of the
project are made so that at all stages of the project test-driven development is possible as all stages rely

% risks: linear structure; dependent on previous stuff; correctness dependency

planned so that it ensures 

cite Software engineeering BS

\section{Summary}
This section summed up the theory background which was needed to complete this dissertation.
It also shows the preparation I undertook in the software engineering aspects of the project.

\begin{itemize}
  \item I briefly introduced the programming language Eff and talked about its characteristic features.
  \item I talked about the operational and denotational semantics of core Eff as well as a type and effect
    system one can use with it. We saw that with-handle blocks compose naturally as opposed to monads in Haskell
    where the use of monad transformers is unnatural.
  \item I explained the idea of a continuation, how it represents an arbitrary program point in the
    execution of a program and how it allows advanced control flow to be implemented.
  \item I gave an overview of control operators (including Landin's J operator), why they were studied in the 
    early days of programming languages and their r√¥le in the development of different virtual machines.
  \item I showed two examples of virtual machines which can implement the structured non-local
    flow of control continuations make possible. The key challenge these machines solve is that
    they can save and restore execution contexts in an appropriate way whenever non-local control flow occurs.

    A CEK machine does this by keeping a stack of continuations (K), while the SECD machine does this by using
    a dump (D). The importance of these machines will appear in the Implementation section where I describe the
    Yoyo virtual machine for Eff which has similarities with both of these virtual machines.
  \item I stated my starting point, the timeline of my project and discussed the development methodology used
    to write the code and the testing strategy to assess its correctness.
\end{itemize}

% kell motivacio section

\section{Computational effects}

There are two types of programs: pure and effectful (or impure). Pure programs are ones that are independent from the environment and effectful programs are the ones that \emph{do} something in the
sense that they interact with their environment. Another way of defining pure functions is: given the definition of the function and its arguments, its result is uniquely determined.

Programs invoking computational effects such as nondeterminism, probabilistic nondeterminism, exceptions, interactive input/output or side effects all constitute as effectful. This is obvious for
interactive input/output, nondeterminism and side-effects as these obviously interact with the environment. Exceptions are a bit awkward in the sense that throwing them is pure but catching them is
not (consider catching an exception that is thrown due to an out-of-memory error; catching this exception would mean that we interact with the environment in an implicit way).

Reasoning about pure programs is easy, as pure computations (partial functions) are well understood. However, most programs must \emph{do} something with the real world (write to a file, 
read from a network socket, handle errors, generate random numbers, etc.) and perform effects to be useful.
Hence, to be able to reason about our programs we must properly understand the properties of these effects, how they work, how they interact and what rules apply to them. To do this, we try to model
them in a framework that was always know to work: mathematics.



\subsection{Eff}

This subsection gives a short introduction to Eff with some code examples.
The precise syntax and semantics of the language will be defined later,
we aim for an intuitive introduction here.

\subsubsection{Effects}

There is an important distinction between syntactic and semantic elements in the language. Effect declarations belong to syntax.

An effect in Eff is declared using the \verb|effect| keyword together with a type signature which forms the effect signature. One would define a \verb|Print| effect for printing strings as follows:



This tells us two things. To invoke the \verb|Print| effect we must provide a string as an argument and what we get back is something of type \verb|unit| after the effect is performed. We get to know no extra information about \verb|Print|.

Now that we have a \verb|Print| effect we can write down the mandatory Hello World example:
\begin{verbatim}
perform (Print "Hello World!")
\end{verbatim}

The \verb|perform| keyword is used to perform already declared effects. However, if we think about it, this piece of code still does
not make any sense as we don't know how to interpret \verb|Print "Hello World!"|.

\subsubsection{Handlers}

Handlers are used to assign meaning to effects. A handler is just a list of rules. A rule can be of three different types: a value rule, an effect rule or a finally rule.

\textbf{Value and effect rules}

The following handler provides an interpretation for the \verb|Print| effect. This handler converts the result of a computation to a 2-tuple where the first element is the original result and the second
element is a concatenation of the strings from all the \verb|Print| effects from the computation.

We use the value rule \verb|v -> (v, "")| to say what happens ``by default''. If the computation didn't print anything then we simply say that it printed the empty string.

\begin{verbatim}
let collect = handler
| v -> (v, "")
| effect (Print str) k ->
    (* Find out what the rest of the computation would print out *)
    let (result, s) = continue k () in
    (* Prefix the string printed by the rest of the computation 
       with `str` from this effect *)
    (result, str ^ s)
\end{verbatim}

The effect rule is a bit more involved. Effect rules have the form \verb|effect E(args) k| where \verb|k| is always bound to the ``rest of the computation'' which we call a continuation (and by convention
usually use the letter $k$ or $\kappa$ to denote it). The arguments of the effect \verb|E| are bound to \verb|args| via pattern matching. In the example above we first resume the computation by resuming the
computation via \verb|continue|. After we find out what the rest of the computation would print out, we prepend our current string to it.

Note that when we handle an effect of type $\alpha \to \beta$ we get a continuation of type $\beta \to \gamma$ where $\gamma$ is the type of the computation being enclosed in a \verb|with ... handle| block.

Value rules can be omitted in handler definitions, in which case they are assumed to be identities.

\textbf{Finally rules}

Finally rules are just syntactic sugar for \verb|let| wrappers around \verb|with ... handle| statements that act on the result of a handled computation, i.e.,
\begin{verbatim}
let h = handler
    | finally x -> x + x
in 
    with h handle c
\end{verbatim}
would be syntactic sugar for
\begin{verbatim}
let x = with h handle c in x + x.
\end{verbatim}

I would like to point out that this syntax is added only for convenience as it happens many times that the same transformations must be performed after a \verb|with ... handle| block \cite{bauer2015programming}. Hence \verb|finally| here does not provide the Java-like semantics where the computation in a finally block is ``guaranteed'' to be executed.

Finally rules can be omitted in handler definitions, in which case they are assumed to be identities.

\textbf{Handler types}

Handlers handling a computation of type $\alpha$ and giving a result of type $\beta$ are given the type $\alpha \Rightarrow \beta$.

\subsection{Advantages}

Now that we introduced Eff, let's switch focus and think about the programming paradigms handlers introduce.

\subsubsection{OOP and functional style}

We can think about effect signatures as interfaces and handlers as implementations of these interfaces.
A \verb|with h handle c| block is then an ``instantiation'' of effect implementations.

We see that programming with effect handlers puts us between the object-oriented and functional styles and gives us more opportunities to re-use existing pieces of code (see next code example).

\subsubsection{Direct style}

The following example shows an implementation of the state monad (borrowed from the official Eff website \cite{eff-website}):
\begin{verbatim}
effect Get: int
effect Set: int -> unit

let monad_state initial = handler
  | y -> (fun s -> (y, s))
  | effect Get k -> (fun s -> (continue k s) s)
  | effect (Set s') k -> (fun _ -> (continue k ()) s')
  | finally f -> f initial
;;

let double_and_add_ten () =
  let x = perform Get in
  perform (Set (2 * x));
  perform Get + 10
;;

with monad_state 30 handle
  double_and_add_ten ()
;;
\end{verbatim}

Note how the function \verb|double_and_add_ten| is written in a direct style. As mentioned above, the programmer does not have to 
be aware of the implementations of the effects (indeed, we see that the ``internal'' representation of state uses functions). 
This function illustrates how handlers increase the modularity of our programs (we could use the function in the context of other handlers 
and perhaps get some other result).

\subsubsection{Composition}

Monads are frequently used as a way to simulate effectful computations in programming languages like Haskell. 
However, combining different kinds of effects in these languages can be non-trivial and 
tiresome sometimes. Haskell uses monad stacks and monad transformers to get around this. [TODO: someone might not know what this is]

In Eff, combining effects and their handlers arises naturally. Handlers can be written for any set of effects and handlers can be combined 
with nesting \verb|with ... handle| blocks.

[TODO: I need two code examples here to justify the claims above and show that \verb|with ... handle| is more convenient. One in Haskell with monad transformers and one in Eff with two nested handlers.]

\subsection{Criticism}

Although there are many attractive properties of effect handlers, one that is frequently quoted to be ``annoying'' is that it is very easy to write incomprehensible code via continuations.
Continuations are not a novel concept but it is one that perhaps isn't widely known by the wider software engineering community. Hence providing the concrete implementation of effects
can impose some extra burden on a programmer's brain.


\subsection{What this dissertation is about}

Algebraic effects and their handlers lie in the heart of the Eff language.
This dissertation is concerned with building and assessing the performance of an Eff compiler.
I describe a CEK-like abstract machine in the implementation section and how that can be turned
into a more efficient Multicore OCaml-like virtual machine built on top of fibers.

This dissertation fits in the broader area of work as I hope to show that algebraic effect handlers
are not just an exciting esoteric research programming language construct with a nice theoretic background, but programming with them comes with benefits and it is possible to compile them efficiently (or at least that the cost of compilation is not too great compared to the benefits they provide).

\subsection{TODOs}
\begin{itemize}
\item I haven't said anything about continuations yet
\item I haven't said anything about shallow and deep handlers
\item Comparing to haskell monads/monad transformers is risky -- need to explain these
\end{itemize}

\section{Papers}
\begin{itemize}
\item Delimited control \cite{kiselyov2010delimited}
\item Eff Directly in OCaml \cite{Kiselyov_2018}
\item Very good article about CPS compilation \cite{flanagan1993essence}
\item Bauer tutorial \cite{bauer2018algebraic}
\end{itemize}

\section{Tikz}
\subsection{Project structure}

\begin{figure}
\begin{tikzpicture}
  \node[draw,inner sep=10pt] (LEX) at (0,6) {Lexer};
  \node[draw,inner sep=10pt] (PAR) at (0,4) {Parser};
  \node[draw,inner sep=10pt] (TYPE) at (0,2) {Type and effect checking};
  \node[draw,inner sep=10pt] (MID) at (5, 2) {Middle-end};
  \node[draw,inner sep=10pt] (COMP) at (9,2) {Compiler};
  \node[draw,inner sep=10pt] (CEK) at (0,0) {CEK machine};
  \node[draw,inner sep=10pt] (YOYO) at (9,0) {YoYo machine};
  
  \draw[->] (LEX) -- (PAR);
  \draw[->] (PAR) -- (TYPE) node[midway, right] {Parse trees};
  \draw[->] (TYPE) -- (CEK) node[midway, right] {ASTs};
  \draw[->] (TYPE) -- (MID) node[midway, above] {ASTs};
  \draw[->] (MID) -- (COMP) node[midway, above] {IR};
  \draw[->] (COMP) -- (YOYO) node[midway, right] {byte code};
\end{tikzpicture}
\caption{Project structure}
\label{fig:project-structure}
\end{figure}

The project structure can be seen on \autoref{fig:project-structure}.

\subsection{Repository structure}

\subsection{CEK machines}

\begin{itemize}
  \item K stands for kontinuation
  \item 
\end{itemize}


\subsection{SECD machines}

\begin{itemize}
  \item Landin' machine
  \item Lower level than CEK machine
  \item Can implement continuations with it
  \item Dump is important
  \item Cite \cite{landin-secd}
\end{itemize}


\ifstandalone
\bibliography{../bibliography}{}
\bibliographystyle{plain}
\fi

\end{document}